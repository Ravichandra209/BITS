package graphs;

import java.util.Iterator;
import java.util.LinkedList;
import graphs.GraphAdjacencyList2.*;
import queues.Queue;

public  class BreadthFirstSearch {
	String color;
	int distance ,parent;
	int restVertices[] ;
	
	public void otherVertices(Graph graph,int source){
		 this.color ="white";
		 this.distance =999 ; //set some higher distance her infinity represented by 999
		 this.parent = -1 ; // Nil represented by -1 
		 restVertices =new int[graph.v-1];
		 
		for(int v =1 ,j=0 ;  j < graph.v-1 && graph.v != source; v++,j++) {
				this.restVertices[j] =v;
		}
	}
	public  void sourceAttributes(int source){
		this.color = "gray" ;
		this.distance = 0;
		this.parent = -1 ;
	}
	
	public void BreadthFirst(Graph graph ,int source) {
		//set the source attributes 
		sourceAttributes(source);
		otherVertices(graph,source);
		
		// Create a queue for BFS 
        //LinkedList<Integer> queue = new LinkedList<Integer>();
        Queue que = new Queue(graph.v);
        	que.enqueue(source);
        	while(!que.isEmpty(que)) {
        		int u = que.dequeue();
        		System.out.println("dequeued is "+ u);
        		//for(int v=0 ; v == graph.adjListArray[v] ; v++) - this gives incomparable operand types 
        		for (Integer pCrawl : graph.adjListArray[u]) {
        			System.out.println("Adjacency List for vertex " + u + " -> " + pCrawl) ;       			
        		}
        		Iterator<Integer> i = graph.adjListArray[u].listIterator(); 
        		//System.out.println("next :" + i.next());
        		System.out.println(i.next() +" "+ this.color + " " + this.distance +" " + this.parent);
        		System.out.println("=================");
        		while(i.hasNext()) {
        			if (this.color=="white") {
        				this.color="gray";
        				this.distance = this.distance +1 ;
        				this.parent = u;
        				System.out.println(i.next() +" "+ this.color + " " + this.distance +" " + this.parent);
        				que.enqueue(i.next());
        			}
        		}
        		this.color="black";
        	}
	}	
}
